import abc
from typing import *

from threading_manager import ThreadsManager

from . import *
from . import TestCase


# =====================================================================================================================
class Dut:
    PRESENT: Optional[bool] = None
    TP_RESULTS: Dict[Type[TestCase], TestCase] = None   # dict is very convenient!!!

    check_present: Callable[..., bool]

    def mark_present(self) -> None:
        self.PRESENT = self.check_present()

    def check_result_final(self) -> Optional[bool]:
        for tc in self.TP_RESULTS.values():
            if tc.SKIP:
                continue
            if not tc.result:
                return tc.result
        return True


# =====================================================================================================================
class TpManager(abc.ABC):
    TCS: Dict[Type[TestCase], Optional[bool]] = None    # settings
    # {
    #     TC1: True,
    #     TC2: True
    # }
    DUTS: List[Dut] = None    # autogenerated
    # [
    #     Dut1,
    #     Dut2
    # ]

    def __init__(self):
        self.reinit()

    def reinit(self) -> None:
        self.DUTS = []
        self.TCS_apply_skipped()

        self.duts_generate()
        self.duts_mark_presented()
        self.duts_results_init()

    def reinit_new_TCS(self, tcs: Dict[Type[TestCase], Optional[bool]]) -> None:
        self.TCS = tcs
        self.reinit()

    # TCS -----------------------------------------------------------
    def TCS_apply_skipped(self):
        for tc, using in self.TCS.items():
            tc.SKIP = not using

    # DUTS -----------------------------------------------------------
    @abc.abstractmethod
    def duts_generate(self) -> None:
        pass

    def duts_mark_presented(self) -> None:
        for dut in self.DUTS:
            dut.mark_present()

    def duts_results_init(self) -> None:
        for dut in self.DUTS:
            dut.TP_RESULTS = dict()
            for tc in self.TCS:
                dut.TP_RESULTS.update({tc: tc(dut)})

    # RUN -----------------------------------------------------------
    def run(self) -> None:
        for tc in self.TCS:
            if tc.SKIP:
                continue
            if not tc.startup_all():
                continue

            ThreadsManager().thread_items__clear()
            for dut in self.DUTS:
                if dut.PRESENT:
                    if tc.PARALLEL:
                        ThreadsManager().decorator__to_thread(dut.TP_RESULTS[tc].run)()
                    else:
                        dut.TP_RESULTS[tc].run()

            if tc.PARALLEL:
                ThreadsManager().wait_all()
            tc.teardown_all()


# =====================================================================================================================
