# from . import *
from .tc import TestCaseBase
from .devices import DutBase, DeviceBase
from .gui import TpGuiBase
from .api import TpApi

from typing import *
import json
from pathlib import Path
from PyQt5.QtCore import QThread
from importlib import import_module

from pyqt_templates import *
from server_templates import ServerAiohttpBase
from object_info import ObjectInfo
from private_values import PrivateJson


# =====================================================================================================================
class Exx__TcsPathNotExists(Exception):
    pass


class Exx__TcItemNotFound(Exception):
    pass


class Exx__TcItemType(Exception):
    pass


class Exx__TcSettingsIncorrect(Exception):
    pass


# =====================================================================================================================
class TpMultyDutBase(QThread):
    signal__tp_start = pyqtSignal()
    signal__tp_stop = pyqtSignal()
    signal__tp_finished = pyqtSignal()

    # SETTINGS ------------------------------------------------------
    STAND_ID: Optional[str] = "stand_id__1"
    STAND_TYPE: Optional[str] = "stand_type"
    STAND_DESCRIPTION: Optional[str] = "stand_description"

    START_API: bool = True
    CLS_API: Type[ServerAiohttpBase] = TpApi

    START_GUI: bool = True
    CLS_GUI: Type[TpGuiBase] = TpGuiBase

    # DIRPATH_TPS: Union[str, Path] = "TESTPLANS"
    DIRPATH_TCS: Union[str, Path] = "TESTCASES"
    # DIRPATH_DEVS: Union[str, Path] = "DEVICES"
    SETTINGS_BASE_NAME: Union[str, Path] = "SETTINGS_BASE.json"
    SETTINGS_BASE_FILEPATH: Path

    # AUX -----------------------------------------------------------
    TCS: Dict[Union[str, Type[TestCaseBase]], Optional[bool]] = {}
    # {
    #     Tc1: True,
    #     Tc2: True
    # }

    # DEVICES: List[Union[str, Type[DeviceBase]]]    # settings
    # [
    #     Dev1,
    #     Dev2
    # ]

    DUTS: List[DutBase] = []    # autogenerated
    tc_active: Optional[Type[TestCaseBase]] = None
    progress: int = 0

    def __init__(self):
        super().__init__()
        # self.DIRPATH_TPS: Path = Path(self.DIRPATH_TPS)
        self.DIRPATH_TCS: Path = Path(self.DIRPATH_TCS)
        # self.DIRPATH_DEVS: Path = Path(self.DIRPATH_DEVS)
        self.SETTINGS_BASE_FILEPATH = self.DIRPATH_TCS.joinpath(self.SETTINGS_BASE_NAME)

        if not self.DIRPATH_TCS.exists():
            msg = f"[ERROR] not found path {self.DIRPATH_TCS.name=}"
            print(msg)
            raise Exx__TcsPathNotExists(msg)

        if not self.TCS:
            for file in self.DIRPATH_TCS.glob("*.py"):
                if not file.stem.startswith("__"):
                    self.TCS.update({file.stem: True})

        self.reinit()

        self.signal__tp_start.connect(self.start)
        self.signal__tp_stop.connect(self.terminate)

        self.api = self.CLS_API(self)
        # self.gui = self.CLS_GUI(self)

        if self.START_API:
            self.start_api()

        if self.START_GUI:
            self.start_gui()

    def start_api(self) -> None:
        self.api.start()

    def start_gui(self) -> None:
        self.CLS_GUI(self)
        # this will BLOCK process
        # this will BLOCK process
        # this will BLOCK process
        # this will BLOCK process
        # this will BLOCK process
        # this will BLOCK process
        # this will BLOCK process
        # this will BLOCK process

    def reinit(self, tcs: Optional[Dict[Type[TestCaseBase], Optional[bool]]] = None) -> Optional[NoReturn]:
        # TCS --------------------------------------------------------------
        tcs = tcs or dict(self.TCS)
        self.TCS = {}

        # # SETTINGS BASE ----------------------------------------
        # settings_base = {}
        # if self.SETTINGS_BASE_FILEPATH.exists():
        #     settings_base = json.loads(self.SETTINGS_BASE_FILEPATH.read_text())

        # WORK ----------------------------------------
        for item, using in tcs.items():
            # print(dir(TESTCASES))
            if isinstance(item, str):   # filename
                # tc_cls = import_module(item, "TESTCASES").TestCase    # not working!
                # tc_cls = getattr(TESTCASES, item).TestCase      # not working
                tc_cls = import_module(f"{self.DIRPATH_TCS.name}.{item}").TestCase
                if not tc_cls:
                    msg = f"[ERROR] file not found[{item=}] in /{self.DIRPATH_TCS.name}/"
                    raise Exx__TcItemNotFound(msg)
                tc_cls.NAME = item
            elif isinstance(type(item), type) and issubclass(item, TestCaseBase):
                tc_cls = item
                # msg = f"[ERROR] DONT USE IT!"
                # raise Exception(msg)
            else:
                msg = f"[ERROR] type is inconvenient [{item=}]"
                raise Exx__TcItemType(msg)

            tc_cls.SKIP = not using
            self.TCS.update({tc_cls: using})

            # SETTINGS TC ----------------------------------------
            tc_cls.SETTINGS_FILES = [self.SETTINGS_BASE_FILEPATH, ]

            settings_tc_filepath = self.DIRPATH_TCS.joinpath(f"{item}.json")
            if settings_tc_filepath.exists():
                tc_cls.SETTINGS_FILES.append(settings_tc_filepath)
            else:
                print(f"{settings_tc_filepath=} NOT_EXISTS")
                pass

        # print(f"{tc_cls.SETTINGS=}")

        # DUTS --------------------------------------------------------------
        self.DUTS = []
        self.duts_generate()
        self._duts_mark_presented()
        self._duts_results_tp_init()

    # TCS -----------------------------------------------------------
    @property
    def tcs_active(self) -> List[TestCaseBase]:
        result = []

        if self.tc_active:
            for dut in self.DUTS:
                tc_dut = dut.TP_RESULTS[self.tc_active]
                if not tc_dut.skip_tc_dut:
                    result.append(tc_dut)
        return result

    # DUTS -----------------------------------------------------------
    def duts_generate(self) -> None:
        # raise NotImplemented
        pass

    def _duts_mark_presented(self) -> None:
        for dut in self.DUTS:
            dut.mark_present()

    def _duts_results_tp_init(self) -> None:
        for dut in self.DUTS:
            dut.TP_RESULTS = dict()
            for tc in self.TCS:
                dut.TP_RESULTS.update({tc: tc(dut)})

    def _duts_results_tc_clear(self) -> None:
        for dut in self.DUTS:
            dut.results_tc_clear()

    # --------------------------------------------------------------------
    def terminate(self) -> None:
        super().terminate()

        # TERMINATE CHILDS!!! ---------------------
        # ObjectInfo(self.currentThread()).print()    # cant find childs!!!

        # finish current ----------------------------
        if self.tc_active:
            self.tc_active.terminate_all()
            self.tc_active = None

        self.signal__tp_finished.emit()

    def run(self) -> None:
        # if self.isRunning():
        #     self.terminate()

        self.progress = 1
        self._duts_mark_presented()
        self._duts_results_tc_clear()

        for step, tc in enumerate(self.TCS, start=1):
            self.progress = int(step / len(self.TCS) * 100) - 1
            self.tc_active = tc
            tc.run_all(self.DUTS)

        # FINISH TPlan ---------------------------------------------------
        self.tc_active = None
        self.progress = 100
        self.signal__tp_finished.emit()

    # =================================================================================================================
    def info_get(self) -> Dict[str, Union[str, None, bool, int, dict, list]]:
        TP_TCS = []
        for tc in self.TCS:
            TP_TCS.append(tc.info_get())

        result = {
            # BASE STRING INFO
            "STAND_ID": self.STAND_ID,
            "STAND_TYPE": self.STAND_TYPE,
            "STAND_DESCRIPTION": self.STAND_DESCRIPTION,

            # AUX
            "TP_TCS_COUNT": len(self.TCS),
            "TP_DUTS_COUNT": len(self.DUTS),

            # SETTINGS
            "TP_SETTINGS_BASE": {},     # TODO: load json

            # STRUCTURE
            "TP_TCS": TP_TCS,
            "TP_DUTS": [],      # TODO: decide how to use
            # [
            #     # [{DUT1}, {DUT2}, â€¦]
            #     {
            #         DUT_ID: 1  # ??? 	# aux
            #         DUT_SKIP: False
            #     }
            # ]

            }
        return result


# =====================================================================================================================
